import UIKit
import Flutter
import Firebase
#if canImport(FirebaseCrashlytics)
import FirebaseCrashlytics
#endif

// Global signal handler function
func handleCrashSignal(_ signalNumber: Int32) {
  DispatchQueue.global(qos: .utility).async {
    let signalName = getSignalName(signalNumber)
    print("üö® Signal \(signalName) (\(signalNumber)) received")
    print("üßµ Thread: \(Thread.current)")
    
    // Get memory usage
    let memoryUsage = getStaticMemoryUsage()
    print("üì± Memory usage: \(memoryUsage) MB")
    
    // Attempt graceful cleanup
    DispatchQueue.main.async {
      URLCache.shared.removeAllCachedResponses()
      autoreleasepool {
        // Force garbage collection
      }
    }
  }
}

func getSignalName(_ signal: Int32) -> String {
  switch signal {
  case SIGSEGV: return "SIGSEGV"
  case SIGABRT: return "SIGABRT"
  case SIGBUS: return "SIGBUS"
  case SIGILL: return "SIGILL"
  case SIGFPE: return "SIGFPE"
  case SIGPIPE: return "SIGPIPE"
  default: return "UNKNOWN"
  }
}

func getStaticMemoryUsage() -> Double {
  var info = mach_task_basic_info()
  var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
  
  let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
    $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
      task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
    }
  }
  
  if kerr == KERN_SUCCESS {
    return Double(info.resident_size) / 1024.0 / 1024.0
  }
  return 0.0
}

@main
@objc class AppDelegate: FlutterAppDelegate {
    
    // Thread-safe initialization flag
    private var isInitialized = false
    private let initializationQueue = DispatchQueue(label: "com.digital.payments.initialization", qos: .userInitiated)
    
    override func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        
        // Ensure we're on the main thread for UI operations
        assert(Thread.isMainThread, "AppDelegate initialization must be on main thread")
        
        // Setup crash prevention first
        setupCrashPrevention()
        
        // Initialize Firebase and plugins safely
        initializeServicesThreadSafe()
        
        return super.application(application, didFinishLaunchingWithOptions: launchOptions)
    }
    
    private func initializeServicesThreadSafe() {
        initializationQueue.async {
            guard !self.isInitialized else {
                print("Services already initialized")
                return
            }
            
            // Use ThreadingUtils for safer initialization
            ThreadingUtils.safeMainThread(timeout: 10.0) {
                do {
                    // Configure Firebase with thread safety
                    ThreadingUtils.safePluginInitialization(pluginName: "Firebase") {
                        if FirebaseApp.app() == nil {
                            FirebaseApp.configure()
                        }
                    }
                    
                    // Register plugins with enhanced safety using SafePluginRegistrant
                    ThreadingUtils.safePluginInitialization(pluginName: "SafePluginRegistrant") {
                        SafePluginRegistrant.safeRegisterWithRegistry(self)
                    }
                    
                    self.isInitialized = true
                    print("‚úÖ All services initialized successfully")
                    
                } catch {
                    print("üö® Initialization failed: \(error)")
                    // Attempt recovery
                    ThreadingUtils.attemptErrorRecovery()
                }
            }
        }
    }
  
    // Plugin registration is now handled by GeneratedPluginRegistrant
    // which is automatically generated by Flutter
  
  // MARK: - Enhanced Crash Prevention Setup
  private func setupCrashPrevention() {
    // Set up global exception handler with thread safety
    NSSetUncaughtExceptionHandler { exception in
      DispatchQueue.global(qos: .utility).async {
        print("üö® Uncaught exception: \(exception)")
        print("üìç Stack trace: \(exception.callStackSymbols)")
        print("üßµ Thread: \(Thread.current)")
        
        // Log to Firebase Crashlytics if available
        #if canImport(FirebaseCrashlytics)
        Crashlytics.crashlytics().record(error: NSError(domain: "UncaughtException", code: -1, userInfo: [
          NSLocalizedDescriptionKey: exception.description,
          "stackTrace": exception.callStackSymbols
        ]))
        #endif
      }
    }
    
    // Enhanced signal handlers with memory protection
    setupSignalHandler(SIGSEGV, name: "SIGSEGV", description: "Segmentation fault - Invalid memory access")
    setupSignalHandler(SIGABRT, name: "SIGABRT", description: "Abort signal - Program terminated")
    setupSignalHandler(SIGBUS, name: "SIGBUS", description: "Bus error - Invalid memory alignment")
    setupSignalHandler(SIGILL, name: "SIGILL", description: "Illegal instruction")
    setupSignalHandler(SIGFPE, name: "SIGFPE", description: "Floating point exception")
    setupSignalHandler(SIGPIPE, name: "SIGPIPE", description: "Broken pipe")
  }
  
  private func setupSignalHandler(_ signal: Int32, name: String, description: String) {
    Darwin.signal(signal, handleCrashSignal)
  }
  
  private func getMemoryUsage() -> Double {
    return getStaticMemoryUsage()
  }
  
  // MARK: - Enhanced Memory Management
  override func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
    super.applicationDidReceiveMemoryWarning(application)
    
    let memoryUsage = getMemoryUsage()
    print("‚ö†Ô∏è Memory warning received - Current usage: \(memoryUsage) MB")
    
    // Use ThreadingUtils for safer memory cleanup
    ThreadingUtils.performMemoryCleanup()
    
    // Notify Flutter engine safely
    ThreadingUtils.safeMainThread { [weak self] in
      // Flutter engine memory notification is handled by the system
      // No direct engine access needed in FlutterAppDelegate
      print("üîÑ Memory warning handled by Flutter framework")
    }
    
    ThreadingUtils.safeBackground(qos: .utility) { [weak self] in
      let newUsage = self?.getMemoryUsage() ?? 0.0
      print("‚úÖ Memory cleanup completed - New usage: \(newUsage) MB")
    }
  }
  
  // MARK: - Plugin Registry Safety
  override func registrar(forPlugin pluginKey: String) -> FlutterPluginRegistrar? {
    // Add safety check to prevent null pointer access
    guard isInitialized else {
      print("‚ö†Ô∏è Plugin registrar requested before initialization: \(pluginKey)")
      return nil
    }
    
    return super.registrar(forPlugin: pluginKey)
  }
  
  // MARK: - Enhanced Background/Foreground Handling
  override func applicationWillResignActive(_ application: UIApplication) {
    super.applicationWillResignActive(application)
    print("‚è∏Ô∏è App will resign active")
  }
  
  override func applicationDidEnterBackground(_ application: UIApplication) {
    super.applicationDidEnterBackground(application)
    print("üì± App entered background - Memory: \(getMemoryUsage()) MB")
    
    // Use ThreadingUtils for safer background cleanup
    ThreadingUtils.performMemoryCleanup()
    
    // Log thread state for debugging
    ThreadingUtils.logCurrentThreadState()
  }
  
  override func applicationWillEnterForeground(_ application: UIApplication) {
    super.applicationWillEnterForeground(application)
    print("üì± App will enter foreground - Memory: \(getMemoryUsage()) MB")
    
    // Log current thread state
    ThreadingUtils.logCurrentThreadState()
    
    // Ensure services are still initialized using ThreadingUtils
    ThreadingUtils.safeMainThread {
      if !self.isInitialized {
        print("‚ö†Ô∏è Services not initialized, reinitializing...")
        self.initializeServicesThreadSafe()
      }
    }
  }
  
  override func applicationDidBecomeActive(_ application: UIApplication) {
    super.applicationDidBecomeActive(application)
    print("‚úÖ App became active - Memory: \(getMemoryUsage()) MB")
  }
}
